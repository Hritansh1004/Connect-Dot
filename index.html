<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dots and Boxes</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"></script>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const { initializeApp } = firebase;
    const { getAuth, signInAnonymously, signInWithCustomToken } = firebase.auth;
    const { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, updateDoc, deleteDoc, getDocs, query, where, arrayUnion } = firebase.firestore;
    firebase.firestore.setLogLevel('debug');
    
    // Global variables from the canvas environment
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : undefined;

    function App() {
      const [db, setDb] = useState(null);
      const [auth, setAuth] = useState(null);
      const [userId, setUserId] = useState(null);
      const [gameId, setGameId] = useState('');
      const [isGameStarted, setIsGameStarted] = useState(false);
      const [dots, setDots] = useState([]);
      const [gridSize, setGridSize] = useState(5);
      const [lines, setLines] = useState([]);
      const [currentTurn, setCurrentTurn] = useState('');
      const [playerScores, setPlayerScores] = useState({});
      const [players, setPlayers] = useState([]);
      const [selectedLine, setSelectedLine] = useState(null);
      const [capturedBoxes, setCapturedBoxes] = useState([]);
      const [message, setMessage] = useState('');
      const [isWaitingForOpponent, setIsWaitingForOpponent] = useState(false);
      const gameRef = useRef(null);

      const colors = ['#EF4444', '#3B82F6', '#10B981', '#F59E0B'];

      useEffect(() => {
        try {
          if (Object.keys(firebaseConfig).length === 0) {
            throw new Error("Firebase config is not defined.");
          }
          const app = initializeApp(firebaseConfig);
          const firestoreDb = getFirestore(app);
          const firebaseAuth = getAuth(app);
          setDb(firestoreDb);
          setAuth(firebaseAuth);

          const signIn = async () => {
            try {
              if (initialAuthToken) {
                await signInWithCustomToken(firebaseAuth, initialAuthToken);
              } else {
                await signInAnonymously(firebaseAuth);
              }
              const currentUser = firebaseAuth.currentUser;
              setUserId(currentUser.uid);
              setMessage("Signed in successfully.");
            } catch (error) {
              setMessage(`Authentication failed: ${error.message}. Please refresh the page.`);
            }
          };
          signIn();
        } catch (error) {
          console.error("Firebase Initialization Error:", error);
          setMessage(`Firebase initialization failed: ${error.message}.`);
        }
      }, []);

      useEffect(() => {
        if (!db || !userId) return;

        if (isGameStarted && gameId) {
          gameRef.current = doc(db, 'artifacts', appId, 'public', 'games', gameId);
          const unsubscribe = onSnapshot(gameRef.current, docSnap => {
            if (docSnap.exists()) {
              const gameData = docSnap.data();
              setLines(gameData.lines);
              setPlayerScores(gameData.scores);
              setCurrentTurn(gameData.currentTurn);
              setPlayers(gameData.players);
              setCapturedBoxes(gameData.capturedBoxes);
              setMessage(gameData.message || '');
              setIsWaitingForOpponent(false);
            }
          });
          return () => unsubscribe();
        }
      }, [db, userId, isGameStarted, gameId]);

      const generateDots = (size) => {
        const newDots = [];
        for (let row = 0; row < size; row++) {
          for (let col = 0; col < size; col++) {
            newDots.push({ id: `${row}-${col}`, row, col });
          }
        }
        setDots(newDots);
        setGridSize(size);
      };

      const handleCreateGame = async () => {
        if (!db || !userId) {
          setMessage("Please wait, authenticating with the server...");
          return;
        }

        try {
          setIsWaitingForOpponent(true);
          const gameCode = Math.random().toString(36).substring(2, 8).toUpperCase();
          const newGameRef = doc(db, 'artifacts', appId, 'public', 'games', gameCode);

          const player = {
            id: userId,
            initial: userId.substring(0, 3).toUpperCase(),
            color: colors[0],
          };

          await setDoc(newGameRef, {
            gridSize,
            lines: [],
            players: [player],
            currentTurn: userId,
            scores: { [userId]: 0 },
            capturedBoxes: [],
            message: `${player.initial} created the game. Waiting for other players...`,
          });
          setGameId(gameCode);
          setIsGameStarted(true);
          setMessage(`Game created! Share this ID with others: **${gameCode}**`);
        } catch (error) {
          console.error("Error creating game:", error);
          setMessage(`Error creating game: ${error.message}`);
          setIsWaitingForOpponent(false);
        }
      };

      const handleJoinGame = async () => {
        if (!db || !userId || !gameId) {
          setMessage("Please enter a game ID.");
          return;
        }

        try {
          const gameRef = doc(db, 'artifacts', appId, 'public', 'games', gameId);
          const docSnap = await getDoc(gameRef);

          if (docSnap.exists()) {
            const gameData = docSnap.data();
            if (gameData.players.length >= 4) {
              setMessage("This game is full. Please try another one.");
              return;
            }
            const isAlreadyPlayer = gameData.players.some(p => p.id === userId);
            if (!isAlreadyPlayer) {
              const newPlayer = {
                id: userId,
                initial: userId.substring(0, 3).toUpperCase(),
                color: colors[gameData.players.length],
              };
              await updateDoc(gameRef, {
                players: arrayUnion(newPlayer),
                [`scores.${userId}`]: 0,
                message: `${newPlayer.initial} has joined the game.`,
              });
            }
            setIsGameStarted(true);
          } else {
            setMessage("Game not found. Please check the ID.");
          }
        } catch (error) {
          console.error("Error joining game:", error);
          setMessage(`Error joining game: ${error.message}`);
        }
      };
      
      const handleConfirmMove = async () => {
        if (!db || !gameId || !selectedLine || currentTurn !== userId) return;

        try {
          const newLines = [...lines, selectedLine];
          let newCapturedBoxes = [...capturedBoxes];
          let newScores = { ...playerScores };
          let newCurrentTurn = currentTurn;
          let claimedBox = false;

          const boxKeys = getPossibleBoxes(selectedLine);
          const linesAfterMove = newLines.map(l => l.id);

          boxKeys.forEach(box => {
            const hasAllSides = box.sides.every(side => linesAfterMove.includes(side.id));
            if (hasAllSides && !newCapturedBoxes.some(b => b.key === box.key)) {
              newCapturedBoxes.push({
                key: box.key,
                owner: userId,
                initial: players.find(p => p.id === userId)?.initial,
                color: players.find(p => p.id === userId)?.color,
              });
              newScores[userId] = (newScores[userId] || 0) + 1;
              claimedBox = true;
            }
          });

          let nextTurnIndex = players.findIndex(p => p.id === currentTurn) + 1;
          if (nextTurnIndex >= players.length) {
            nextTurnIndex = 0;
          }
          if (!claimedBox) {
            newCurrentTurn = players[nextTurnIndex]?.id;
          } else {
            newCurrentTurn = currentTurn;
          }
          const allPossibleLines = getPossibleLines(gridSize);
          if (newLines.length === allPossibleLines.length) {
            setMessage("Game over! Calculating scores...");
          } else {
            setMessage(claimedBox ? "You captured a box! Take another turn." : `It's ${players.find(p => p.id === newCurrentTurn)?.initial}'s turn.`);
          }

          await updateDoc(gameRef.current, {
            lines: newLines,
            scores: newScores,
            capturedBoxes: newCapturedBoxes,
            currentTurn: newCurrentTurn,
            message: claimedBox ? "You captured a box! Take another turn." : `It's ${players.find(p => p.id === newCurrentTurn)?.initial}'s turn.`,
          });
          setSelectedLine(null);

        } catch (error) {
          console.error("Error confirming move:", error);
          setMessage(`Error confirming move: ${error.message}`);
        }
      };
      const handleUndo = () => {
        setSelectedLine(null);
      };
      const handleClickLine = (line) => {
        if (currentTurn !== userId) {
          setMessage("It's not your turn.");
          return;
        }
        if (lines.some(l => l.id === line.id)) {
          setMessage("That line is already drawn.");
          return;
        }
        setSelectedLine(line);
      };
      const getPossibleLines = (size) => {
        const possibleLines = [];
        for (let row = 0; row < size; row++) {
          for (let col = 0; col < size; col++) {
            if (col < size - 1) {
              possibleLines.push({ id: `h-${row}-${col}`, start: { row, col }, end: { row, col: col + 1 }, type: 'horizontal' });
            }
            if (row < size - 1) {
              possibleLines.push({ id: `v-${row}-${col}`, start: { row, col }, end: { row: row + 1, col }, type: 'vertical' });
            }
          }
        }
        return possibleLines;
      };
      const getPossibleBoxes = (line) => {
        const possibleBoxes = [];
        if (line.type === 'horizontal') {
          const { row, col } = line.start;
          if (row > 0) {
            possibleBoxes.push({ key: `box-${row - 1}-${col}`, sides: [{ id: `h-${row - 1}-${col}` }, { id: `h-${row}-${col}` }, { id: `v-${row - 1}-${col}` }, { id: `v-${row - 1}-${col + 1}` }] });
          }
          if (row < gridSize - 1) {
            possibleBoxes.push({ key: `box-${row}-${col}`, sides: [{ id: `h-${row}-${col}` }, { id: `h-${row + 1}-${col}` }, { id: `v-${row}-${col}` }, { id: `v-${row}-${col + 1}` }] });
          }
        } else if (line.type === 'vertical') {
          const { row, col } = line.start;
          if (col > 0) {
            possibleBoxes.push({ key: `box-${row}-${col - 1}`, sides: [{ id: `v-${row}-${col - 1}` }, { id: `v-${row}-${col}` }, { id: `h-${row}-${col - 1}` }, { id: `h-${row + 1}-${col - 1}` }] });
          }
          if (col < gridSize - 1) {
            possibleBoxes.push({ key: `box-${row}-${col}`, sides: [{ id: `v-${row}-${col}` }, { id: `v-${row}-${col + 1}` }, { id: `h-${row}-${col}` }, { id: `h-${row + 1}-${col}` }] });
          }
        }
        return possibleBoxes;
      };
      if (!db || !userId) {
        return (
          <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4">
            <div className="bg-white p-8 rounded-xl shadow-lg text-center">
              <div className="text-xl font-bold text-gray-800">Dots and Boxes</div>
              <p className="mt-4 text-gray-600">Loading game data. Please wait...</p>
              <div className="mt-4 w-12 h-12 border-4 border-gray-300 border-t-transparent border-solid rounded-full animate-spin mx-auto"></div>
            </div>
          </div>
        );
      }
      if (!isGameStarted) {
        return (
          <div className="flex items-center justify-center min-h-screen bg-gray-100 p-4">
            <div className="bg-white p-8 rounded-xl shadow-lg w-full max-w-md">
              <h1 className="text-3xl font-bold text-center text-gray-800 mb-6">Dots and Boxes</h1>
              <div className="mb-6">
                <h2 className="text-xl font-semibold mb-2 text-gray-700">Choose Grid Size</h2>
                <div className="grid grid-cols-2 gap-4">
                  <button onClick={() => generateDots(5)} className={`w-full p-3 rounded-lg font-bold transition-transform transform hover:scale-105 ${gridSize === 5 ? 'bg-indigo-600 text-white shadow-md' : 'bg-gray-200 text-gray-700'}`}>5x5 (Quick)</button>
                  <button onClick={() => generateDots(8)} className={`w-full p-3 rounded-lg font-bold transition-transform transform hover:scale-105 ${gridSize === 8 ? 'bg-indigo-600 text-white shadow-md' : 'bg-gray-200 text-gray-700'}`}>8x8 (Standard)</button>
                  <button onClick={() => generateDots(12)} className={`w-full p-3 rounded-lg font-bold transition-transform transform hover:scale-105 ${gridSize === 12 ? 'bg-indigo-600 text-white shadow-md' : 'bg-gray-200 text-gray-700'}`}>12x12 (Long)</button>
                  <button onClick={() => generateDots(15)} className={`w-full p-3 rounded-lg font-bold transition-transform transform hover:scale-105 ${gridSize === 15 ? 'bg-indigo-600 text-white shadow-md' : 'bg-gray-200 text-gray-700'}`}>15x15 (Epic)</button>
                </div>
              </div>
              <div className="flex flex-col space-y-4">
                <button onClick={handleCreateGame} className="bg-indigo-600 text-white p-3 rounded-lg font-bold shadow-lg hover:bg-indigo-700 transition-colors">Create New Game</button>
                <div className="relative">
                  <input type="text" placeholder="Enter Game ID" value={gameId} onChange={(e) => setGameId(e.target.value.toUpperCase())} className="w-full p-3 border-2 border-gray-300 rounded-lg text-center font-bold text-gray-700 uppercase focus:border-indigo-500 focus:ring-indigo-500" />
                  <button onClick={handleJoinGame} className="w-full mt-2 bg-green-600 text-white p-3 rounded-lg font-bold shadow-lg hover:bg-green-700 transition-colors">Join Existing Game</button>
                </div>
              </div>
              {message && (
                <div className="mt-6 p-4 bg-gray-100 rounded-lg text-gray-800 text-center">
                  <p>{message}</p>
                  <p className="font-mono text-sm mt-2">Your User ID: {userId}</p>
                </div>
              )}
            </div>
          </div>
        );
      }
      const myPlayer = players.find(p => p.id === userId);
      const myColor = myPlayer?.color || 'transparent';
      const isGameOver = lines.length === getPossibleLines(gridSize).length;
      const winner = isGameOver ? Object.keys(playerScores).reduce((a, b) => playerScores[a] > playerScores[b] ? a : b) : null;
      const winnerInitial = players.find(p => p.id === winner)?.initial;
      return (
        <div className="flex flex-col min-h-screen bg-gray-100 p-4 font-sans">
          <div className="flex-1 flex flex-col items-center justify-center">
            <div className="text-center mb-6">
              <h1 className="text-4xl font-extrabold text-gray-800 tracking-tight">Dots and Boxes</h1>
              <p className="mt-2 text-sm text-gray-600">Game ID: <span className="font-mono font-bold text-lg text-indigo-600">{gameId}</span></p>
              <p className="mt-1 text-sm text-gray-600">Your User ID: <span className="font-mono text-sm">{userId}</span></p>
            </div>
            <div className="bg-white p-6 rounded-2xl shadow-2xl mb-6 w-full max-w-4xl">
              <div className="flex flex-wrap items-center justify-center space-x-4 mb-6">
                {players.map(player => (
                  <div key={player.id} className={`flex items-center space-x-2 p-3 rounded-xl font-bold text-white shadow-inner transition-all duration-300 ease-in-out transform ${currentTurn === player.id ? 'scale-110 ring-4 ring-offset-2 ring-indigo-500' : ''}`} style={{ backgroundColor: player.color }}>
                    <span>{player.initial}</span>
                    <span className="text-xl">{playerScores[player.id] || 0}</span>
                  </div>
                ))}
              </div>
              {isWaitingForOpponent ? (<p className="text-center text-gray-600 animate-pulse">Waiting for other players to join...</p>) : (
                <div className="text-center text-xl font-semibold mb-4 text-gray-700">
                  {isGameOver ? (winner ? `Game Over! ${winnerInitial} wins!` : "Game Over! It's a tie!") : (
                    <span style={{ color: players.find(p => p.id === currentTurn)?.color }}>
                      It's {players.find(p => p.id === currentTurn)?.initial}'s turn
                    </span>)}
                </div>)}
            </div>
            <div className="relative" style={{ width: `${gridSize * 40 + 20}px`, height: `${gridSize * 40 + 20}px` }}>
              {dots.map(dot => (<div key={dot.id} className="absolute w-2 h-2 rounded-full bg-gray-500" style={{ top: `${dot.row * 40 + 10}px`, left: `${dot.col * 40 + 10}px` }}></div>))}
              {getPossibleLines(gridSize).map(line => {
                const isDrawn = lines.some(l => l.id === line.id);
                const isSelected = selectedLine?.id === line.id;
                const owner = isDrawn ? lines.find(l => l.id === line.id)?.owner : null;
                const ownerColor = players.find(p => p.id === owner)?.color;
                let lineStyle = '';
                if (line.type === 'horizontal') {
                  lineStyle = `h-2 w-[40px] top-[${line.start.row * 40 + 10}px] left-[${line.start.col * 40 + 14}px]`;
                } else {
                  lineStyle = `w-2 h-[40px] top-[${line.start.row * 40 + 14}px] left-[${line.start.col * 40 + 10}px]`;
                }
                return (<div key={line.id} className={`absolute rounded-full transition-all duration-300 ease-in-out ${isDrawn ? '' : (currentTurn === userId ? 'hover:bg-gray-400 cursor-pointer' : '')} `} style={{ ...lineStyle, backgroundColor: isSelected ? myColor : (isDrawn ? ownerColor : 'transparent') }} onClick={() => !isDrawn && currentTurn === userId ? handleClickLine(line) : null}></div>);
              })}
              {capturedBoxes.map(box => (<div key={box.key} className="absolute flex items-center justify-center rounded-lg text-white font-bold text-4xl shadow-md" style={{ top: `${(box.key.split('-')[1] * 40) + 14}px`, left: `${(box.key.split('-')[2] * 40) + 14}px`, width: '32px', height: '32px', backgroundColor: box.color, zIndex: 20 }}>{box.initial}</div>))}
            </div>
            <div className="mt-6 flex space-x-4">
              <button onClick={handleConfirmMove} disabled={!selectedLine || currentTurn !== userId || isGameOver} className={`p-3 rounded-lg font-bold text-white shadow-lg transition-colors ${!selectedLine || currentTurn !== userId || isGameOver ? 'bg-gray-400 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}`}>Confirm Move</button>
              <button onClick={handleUndo} disabled={!selectedLine || currentTurn !== userId || isGameOver} className={`p-3 rounded-lg font-bold text-white shadow-lg transition-colors ${!selectedLine || currentTurn !== userId || isGameOver ? 'bg-gray-400 cursor-not-allowed' : 'bg-red-600 hover:bg-red-700'}`}>Undo</button>
            </div>
            {isGameOver && (<div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
              <div className="bg-white p-8 rounded-xl shadow-2xl text-center">
                <h2 className="text-3xl font-extrabold text-gray-800 mb-4">Game Over!</h2>
                {winner ? (<p className="text-xl text-gray-600">The winner is <span className="font-bold">{winnerInitial}</span> with a score of {playerScores[winner]}!</p>) : (<p className="text-xl text-gray-600">It's a tie!</p>)}
                <div className="mt-6">
                  <h3 className="text-lg font-semibold text-gray-700">Final Scores:</h3>
                  {players.map(player => (<p key={player.id} className="text-md text-gray-600 mt-2">
                    <span className="font-bold" style={{ color: player.color }}>{player.initial}</span>: {playerScores[player.id]} boxes
                  </p>))}
                </div>
              </div>
            </div>)}
          </div>
        </div>
      );
    }
    ReactDOM.render(React.createElement(App, null), document.getElementById('root'));
  </script>
</body>
</html>
